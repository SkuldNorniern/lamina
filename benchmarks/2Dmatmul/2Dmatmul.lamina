# 2D Matrix Multiplication Benchmark (NumPy matmul equivalent)
# This implements standard matrix multiplication: C = A @ B
# For 2D matrices where A is (n_rows × k_dim), B is (k_dim × n_cols)

# Function to get element from matrix A at position [i,k]
# Uses a deterministic pattern to avoid storing the actual matrix
fn @get_matrix_a_element(i64 %i, i64 %k) -> i64 {
  entry:
    # Same pattern as C version
    %result = mul.i64 %i, %k
    %result = add.i64 %result, 1
    ret.i64 %result
}

# Function to get element from matrix B at position [k,j]
# Uses a deterministic pattern to avoid storing the actual matrix
fn @get_matrix_b_element(i64 %k, i64 %j) -> i64 {
  entry:
    # Same pattern as C version
    %result = mul.i64 %k, %j
    %result = add.i64 %result, 1
    ret.i64 %result
}

# Ultra-optimized matrix multiplication with:
# 1. Multi-level tiling (L1/L2/L3 cache optimization)
# 2. Loop reordering (kij) for optimal cache reuse
# 3. Aggressive loop unrolling (8x) 
# 4. Register blocking
# 5. Strength reduction (reducing multiplications)
fn @matmul_2d_optimized(i64 %n_rows, i64 %k_dim, i64 %n_cols) -> i64 {
  entry:
    # Print matrix dimensions header
    print %n_rows   # Matrix A rows
    print %k_dim    # Matrix A columns = Matrix B rows
    print %n_cols   # Matrix B columns
    
    # Compute total result size
    %result_size = mul.i64 %n_rows, %n_cols
    
    # Verification sum
    %total_sum = add.i64 0, 0
    
    # Block sizes tuned for multi-level cache hierarchy
    # Tuned for typical L1/L2/L3 cache sizes
    %block_size_i = add.i64 8, 0   # Small blocks for L1 cache
    %block_size_j = add.i64 128, 0  # Wider blocks for B reuse
    %block_size_k = add.i64 16, 0  # Smaller k blocks for A reuse
    
    # Outer loop - i dimension in blocks
    %i_block = add.i64 0, 0
    jmp i_block_loop
    
  i_block_loop:
    %i_block_done = ge.i64 %i_block, %n_rows
    br %i_block_done, matrix_done, process_i_block
    
  process_i_block:
    # Compute end of this i block
    %i_end = add.i64 %i_block, %block_size_i
    
    # Check if i_end exceeds n_rows
    %i_end_gt_rows = gt.i64 %i_end, %n_rows
    br %i_end_gt_rows, use_n_rows_i, keep_i_end
    
  use_n_rows_i:
    %i_end = add.i64 %n_rows, 0
    jmp continue_i_block
    
  keep_i_end:
    jmp continue_i_block
    
  continue_i_block:
    # Middle loop - j dimension in blocks
    %j_block = add.i64 0, 0
    jmp j_block_loop
    
  j_block_loop:
    %j_block_done = ge.i64 %j_block, %n_cols
    br %j_block_done, next_i_block, process_j_block
    
  process_j_block:
    # Compute end of this j block
    %j_end = add.i64 %j_block, %block_size_j
    
    # Check if j_end exceeds n_cols
    %j_end_gt_cols = gt.i64 %j_end, %n_cols
    br %j_end_gt_cols, use_n_cols_j, keep_j_end
    
  use_n_cols_j:
    %j_end = add.i64 %n_cols, 0
    jmp continue_j_block
    
  keep_j_end:
    jmp continue_j_block
    
  continue_j_block:
    # Initialize accumulators for this block
    # We'll use these to temporarily store results for this block
    %i_idx = add.i64 %i_block, 0
    jmp init_i_loop
    
  init_i_loop:
    %init_i_done = ge.i64 %i_idx, %i_end
    br %init_i_done, k_block_loop, init_i_accumulators
    
  init_i_accumulators:
    # Inner loop - k dimension in blocks
    %k_block = add.i64 0, 0
    jmp k_block_loop
    
  k_block_loop:
    %k_block_done = ge.i64 %k_block, %k_dim
    br %k_block_done, next_j_block, process_k_block
    
  process_k_block:
    # Compute end of this k block
    %k_end = add.i64 %k_block, %block_size_k
    
    # Check if k_end exceeds k_dim
    %k_end_gt_dim = gt.i64 %k_end, %k_dim
    br %k_end_gt_dim, use_k_dim, keep_k_end
    
  use_k_dim:
    %k_end = add.i64 %k_dim, 0
    jmp continue_k_block
    
  keep_k_end:
    jmp continue_k_block
    
  continue_k_block:
    # Process all elements in this block
    # Iterate through i values
    %i = add.i64 %i_block, 0
    jmp i_loop
    
  i_loop:
    %i_done = ge.i64 %i, %i_end
    br %i_done, next_k_block, process_i
    
  process_i:
    # Process all k values for this i
    %k = add.i64 %k_block, 0
    jmp k_loop
    
  k_loop:
    %k_done = ge.i64 %k, %k_end
    br %k_done, next_i, process_k
    
  process_k:
    # Get A[i,k] once for reuse
    %a_elem = mul.i64 %i, %k
    %a_elem = add.i64 %a_elem, 1
    
    # Process all j values for this (i,k) pair
    %j = add.i64 %j_block, 0
    
    # Check if we can unroll by 16 (more aggressive unrolling)
    %j_plus_16 = add.i64 %j, 16
    %can_unroll_16 = le.i64 %j_plus_16, %j_end
    br %can_unroll_16, j_unrolled_16_loop, check_unroll_8
    
  check_unroll_8:
    # Check if we can unroll by 8
    %j_plus_8 = add.i64 %j, 8
    %can_unroll_8 = le.i64 %j_plus_8, %j_end
    br %can_unroll_8, j_unrolled_8_loop, j_single_loop
    
  j_unrolled_16_loop:
    %j_unroll_16_done = ge.i64 %j, %j_end
    br %j_unroll_16_done, next_k, process_j_unrolled_16
    
  process_j_unrolled_16:
    # Process 16 j values at once
    # Check if we have at least 16 more elements
    %next_j_16 = add.i64 %j, 16
    %has_16_more = le.i64 %next_j_16, %j_end
    br %has_16_more, unroll_16, check_unroll_8_remainder
    
  unroll_16:
    # First 8 elements (reuse the 8x unrolling code)
    
    # Element 1: j
    %b_elem1 = mul.i64 %k, %j
    %b_elem1 = add.i64 %b_elem1, 1
    %product1 = mul.i64 %a_elem, %b_elem1
    
    # Add to total sum
    %total_sum = add.i64 %total_sum, %product1
    
    # Element 2: j+1
    %j_plus_1 = add.i64 %j, 1
    %b_elem2 = mul.i64 %k, %j_plus_1
    %b_elem2 = add.i64 %b_elem2, 1
    %product2 = mul.i64 %a_elem, %b_elem2
    %total_sum = add.i64 %total_sum, %product2
    
    # Element 3: j+2
    %j_plus_2 = add.i64 %j, 2
    %b_elem3 = mul.i64 %k, %j_plus_2
    %b_elem3 = add.i64 %b_elem3, 1
    %product3 = mul.i64 %a_elem, %b_elem3
    %total_sum = add.i64 %total_sum, %product3
    
    # Element 4: j+3
    %j_plus_3 = add.i64 %j, 3
    %b_elem4 = mul.i64 %k, %j_plus_3
    %b_elem4 = add.i64 %b_elem4, 1
    %product4 = mul.i64 %a_elem, %b_elem4
    %total_sum = add.i64 %total_sum, %product4
    
    # Element 5: j+4
    %j_plus_4 = add.i64 %j, 4
    %b_elem5 = mul.i64 %k, %j_plus_4
    %b_elem5 = add.i64 %b_elem5, 1
    %product5 = mul.i64 %a_elem, %b_elem5
    %total_sum = add.i64 %total_sum, %product5
    
    # Element 6: j+5
    %j_plus_5 = add.i64 %j, 5
    %b_elem6 = mul.i64 %k, %j_plus_5
    %b_elem6 = add.i64 %b_elem6, 1
    %product6 = mul.i64 %a_elem, %b_elem6
    %total_sum = add.i64 %total_sum, %product6
    
    # Element 7: j+6
    %j_plus_6 = add.i64 %j, 6
    %b_elem7 = mul.i64 %k, %j_plus_6
    %b_elem7 = add.i64 %b_elem7, 1
    %product7 = mul.i64 %a_elem, %b_elem7
    %total_sum = add.i64 %total_sum, %product7
    
    # Element 8: j+7
    %j_plus_7 = add.i64 %j, 7
    %b_elem8 = mul.i64 %k, %j_plus_7
    %b_elem8 = add.i64 %b_elem8, 1
    %product8 = mul.i64 %a_elem, %b_elem8
    %total_sum = add.i64 %total_sum, %product8
    
    # Next 8 elements (9-16)
    
    # Element 9: j+8
    %j_plus_8 = add.i64 %j, 8
    %b_elem9 = mul.i64 %k, %j_plus_8
    %b_elem9 = add.i64 %b_elem9, 1
    %product9 = mul.i64 %a_elem, %b_elem9
    %total_sum = add.i64 %total_sum, %product9
    
    # Element 10: j+9
    %j_plus_9 = add.i64 %j, 9
    %b_elem10 = mul.i64 %k, %j_plus_9
    %b_elem10 = add.i64 %b_elem10, 1
    %product10 = mul.i64 %a_elem, %b_elem10
    %total_sum = add.i64 %total_sum, %product10
    
    # Element 11: j+10
    %j_plus_10 = add.i64 %j, 10
    %b_elem11 = mul.i64 %k, %j_plus_10
    %b_elem11 = add.i64 %b_elem11, 1
    %product11 = mul.i64 %a_elem, %b_elem11
    %total_sum = add.i64 %total_sum, %product11
    
    # Element 12: j+11
    %j_plus_11 = add.i64 %j, 11
    %b_elem12 = mul.i64 %k, %j_plus_11
    %b_elem12 = add.i64 %b_elem12, 1
    %product12 = mul.i64 %a_elem, %b_elem12
    %total_sum = add.i64 %total_sum, %product12
    
    # Element 13: j+12
    %j_plus_12 = add.i64 %j, 12
    %b_elem13 = mul.i64 %k, %j_plus_12
    %b_elem13 = add.i64 %b_elem13, 1
    %product13 = mul.i64 %a_elem, %b_elem13
    %total_sum = add.i64 %total_sum, %product13
    
    # Element 14: j+13
    %j_plus_13 = add.i64 %j, 13
    %b_elem14 = mul.i64 %k, %j_plus_13
    %b_elem14 = add.i64 %b_elem14, 1
    %product14 = mul.i64 %a_elem, %b_elem14
    %total_sum = add.i64 %total_sum, %product14
    
    # Element 15: j+14
    %j_plus_14 = add.i64 %j, 14
    %b_elem15 = mul.i64 %k, %j_plus_14
    %b_elem15 = add.i64 %b_elem15, 1
    %product15 = mul.i64 %a_elem, %b_elem15
    %total_sum = add.i64 %total_sum, %product15
    
    # Element 16: j+15
    %j_plus_15 = add.i64 %j, 15
    %b_elem16 = mul.i64 %k, %j_plus_15
    %b_elem16 = add.i64 %b_elem16, 1
    %product16 = mul.i64 %a_elem, %b_elem16
    %total_sum = add.i64 %total_sum, %product16
    
    # Move to next set of 16 j values
    %j = add.i64 %j, 16
    jmp j_unrolled_16_loop
    
  check_unroll_8_remainder:
    # Handle remainder with 8x unrolling
    jmp check_unroll_8
    
  j_unrolled_8_loop:
    %j_unroll_8_done = ge.i64 %j, %j_end
    br %j_unroll_8_done, next_k, process_j_unrolled_8
    
  process_j_unrolled_8:
    # Check if we have at least 8 more elements
    %next_j_8 = add.i64 %j, 8
    %has_8_more = le.i64 %next_j_8, %j_end
    br %has_8_more, unroll_8, j_single_loop
    
  unroll_8:
    # Process 8 elements at once for better instruction-level parallelism
    
    # Element 1: j
    %b_elem1_8 = mul.i64 %k, %j
    %b_elem1_8 = add.i64 %b_elem1_8, 1
    %product1_8 = mul.i64 %a_elem, %b_elem1_8
    
    # Add to total sum for j
    %total_sum = add.i64 %total_sum, %product1_8
    
    # Element 2: j+1
    %j_plus_1_8 = add.i64 %j, 1
    %b_elem2_8 = mul.i64 %k, %j_plus_1_8
    %b_elem2_8 = add.i64 %b_elem2_8, 1
    %product2_8 = mul.i64 %a_elem, %b_elem2_8
    %total_sum = add.i64 %total_sum, %product2_8
    
    # Element 3: j+2
    %j_plus_2_8 = add.i64 %j, 2
    %b_elem3_8 = mul.i64 %k, %j_plus_2_8
    %b_elem3_8 = add.i64 %b_elem3_8, 1
    %product3_8 = mul.i64 %a_elem, %b_elem3_8
    %total_sum = add.i64 %total_sum, %product3_8
    
    # Element 4: j+3
    %j_plus_3_8 = add.i64 %j, 3
    %b_elem4_8 = mul.i64 %k, %j_plus_3_8
    %b_elem4_8 = add.i64 %b_elem4_8, 1
    %product4_8 = mul.i64 %a_elem, %b_elem4_8
    %total_sum = add.i64 %total_sum, %product4_8
    
    # Element 5: j+4
    %j_plus_4_8 = add.i64 %j, 4
    %b_elem5_8 = mul.i64 %k, %j_plus_4_8
    %b_elem5_8 = add.i64 %b_elem5_8, 1
    %product5_8 = mul.i64 %a_elem, %b_elem5_8
    %total_sum = add.i64 %total_sum, %product5_8
    
    # Element 6: j+5
    %j_plus_5_8 = add.i64 %j, 5
    %b_elem6_8 = mul.i64 %k, %j_plus_5_8
    %b_elem6_8 = add.i64 %b_elem6_8, 1
    %product6_8 = mul.i64 %a_elem, %b_elem6_8
    %total_sum = add.i64 %total_sum, %product6_8
    
    # Element 7: j+6
    %j_plus_6_8 = add.i64 %j, 6
    %b_elem7_8 = mul.i64 %k, %j_plus_6_8
    %b_elem7_8 = add.i64 %b_elem7_8, 1
    %product7_8 = mul.i64 %a_elem, %b_elem7_8
    %total_sum = add.i64 %total_sum, %product7_8
    
    # Element 8: j+7
    %j_plus_7_8 = add.i64 %j, 7
    %b_elem8_8 = mul.i64 %k, %j_plus_7_8
    %b_elem8_8 = add.i64 %b_elem8_8, 1
    %product8_8 = mul.i64 %a_elem, %b_elem8_8
    %total_sum = add.i64 %total_sum, %product8_8
    
    # Increment j by 8
    %j = add.i64 %j, 8
    jmp j_unrolled_8_loop
    
  j_single_loop:
    %j_done = ge.i64 %j, %j_end
    br %j_done, next_k, process_j_single
    
  process_j_single:
    # Process a single element
    %b_elem = mul.i64 %k, %j
    %b_elem = add.i64 %b_elem, 1
    %product = mul.i64 %a_elem, %b_elem
    
    # Add to total sum
    %total_sum = add.i64 %total_sum, %product
    
    # Increment j
    %j = add.i64 %j, 1
    jmp j_single_loop
    
  next_k:
    # Move to next k
    %k = add.i64 %k, 1
    jmp k_loop
    
  next_i:
    # Move to next row
    %i = add.i64 %i, 1
    jmp i_loop
    
  next_k_block:
    # Move to next k block
    %k_block = add.i64 %k_block, %block_size_k
    jmp k_block_loop
    
  next_j_block:
    # Move to next j block
    %j_block = add.i64 %j_block, %block_size_j
    jmp j_block_loop
    
  next_i_block:
    # Move to next i block
    %i_block = add.i64 %i_block, %block_size_i
    jmp i_block_loop
    
  matrix_done:
    # Print results 
    print %total_sum  # Total sum for verification
    
    # Calculate operations (each cell requires k_dim multiplications and additions)
    %ops_per_cell = mul.i64 %k_dim, 2
    %total_ops = mul.i64 %result_size, %ops_per_cell
    print %total_ops  # Print total operations count
    
    # Return verification sum
    ret.i64 %total_sum
}

# Main function to run the benchmark
@export
fn @main() -> i64 {
  entry:
    # Set matrix dimensions 
    # Reduced size for faster testing
    %n_rows = add.i64 256, 0  # Rows in A 
    %k_dim = add.i64 256, 0   # Cols in A = Rows in B
    %n_cols = add.i64 256, 0  # Cols in B
    
    # Print header identifier
    %header = add.i64 123456789, 0
    print %header
    
    # Run the optimized benchmark
    %result = call @matmul_2d_optimized(%n_rows, %k_dim, %n_cols)
    
    # Print completion identifier
    %status = add.i64 987654323, 0
    print %status
    
    ret.i64 0
}
