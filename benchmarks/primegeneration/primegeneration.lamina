# Prime Generation Benchmark
# Counts prime numbers up to given limits using trial division
# Implements primality testing using efficient modulo operations

# Function to check if a number is prime using efficient modulo operations
@inline
fn @is_prime(i64 %n) -> i64 {
  entry:
    # Handle base cases
    %is_le_1 = le.i64 %n, 1
    br %is_le_1, is_prime_not_prime, is_prime_check_2

  is_prime_check_2:
    %is_2 = eq.i64 %n, 2
    br %is_2, is_prime_prime, is_prime_check_3

  is_prime_check_3:
    %is_3 = eq.i64 %n, 3
    br %is_3, is_prime_prime, is_prime_check_even

  is_prime_check_even:
    # Check if even (divisible by 2)
    %mod_2 = rem.i64 %n, 2
    %is_even = eq.i64 %mod_2, 0
    br %is_even, is_prime_not_prime, is_prime_start_loop

  is_prime_start_loop:
    # Check divisibility by odd numbers from 3 up to sqrt(n)
    %d = add.i64 3, 0
    jmp is_prime_loop_condition

  is_prime_loop_condition:
    # If d*d > n, then n is prime
    %d_squared = mul.i64 %d, %d
    %d_sq_gt_n = gt.i64 %d_squared, %n
    br %d_sq_gt_n, is_prime_prime, is_prime_loop_body

  is_prime_loop_body:
    # Check if n is divisible by current d
    %remainder = rem.i64 %n, %d
    %is_divisible = eq.i64 %remainder, 0
    br %is_divisible, is_prime_not_prime, is_prime_next_d

  is_prime_next_d:
    # Try next odd divisor
    %d = add.i64 %d, 2
    jmp is_prime_loop_condition

  is_prime_prime:
    ret.i64 1

  is_prime_not_prime:
    ret.i64 0
}

# Function to count primes up to a limit
@inline
fn @count_primes(i64 %limit) -> i64 {
  entry:
    # Initialize: current = 2, count = 0
    %current = add.i64 2, 0
    %count = add.i64 0, 0
    jmp count_loop_condition

  count_loop_condition:
    # If current > limit, return count
    %current_gt_limit = gt.i64 %current, %limit
    br %current_gt_limit, count_return, count_loop_body

  count_loop_body:
    # Check if current number is prime
    %is_current_prime = call @is_prime(%current)
    br %is_current_prime, count_increment, count_next

  count_increment:
    %count = add.i64 %count, 1
    jmp count_next

  count_next:
    %current = add.i64 %current, 1
    jmp count_loop_condition

  count_return:
    ret.i64 %count
}

@export
fn @main() -> i64 {
  entry:
    # Print header marker
    print 123456789

    # Count primes up to different limits
    %count_100 = call @count_primes(100)
    print %count_100

    %count_1000 = call @count_primes(1000)
    print %count_1000

    %count_10000 = call @count_primes(10000)
    print %count_10000

    %count_50000 = call @count_primes(50000)
    print %count_50000

    # Print footer marker
    print 987654321

    ret.i64 0
}
