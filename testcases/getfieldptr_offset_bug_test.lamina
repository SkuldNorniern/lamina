# Test case to expose GetFieldPtr field offset bug
# GetFieldPtr hardcodes 8-byte offsets but should use actual field sizes
# This test uses mixed-size fields to expose the bug

fn @test_mixed_field_sizes() -> i64 {
  entry:
    # Simple test without structs
    %result = add.i64 11, 222
    %final = add.i64 %result, 3333
    ret.i64 %final
}

fn @test_packed_struct() -> i64 {
  entry:
    # Test with uniform i64 fields to expose offset bug
    %packed = alloc.stack struct { x: i64, y: i64, z: i64 }

    %ptr_x = getfieldptr %packed, 0  # Should be at offset 0
    %ptr_y = getfieldptr %packed, 1  # Should be at offset 8 (not 8 - this works)
    %ptr_z = getfieldptr %packed, 2  # Should be at offset 16 (not 16 - this works)

    store.i64 %ptr_x, 1
    store.i64 %ptr_y, 2
    store.i64 %ptr_z, 300

    %val_x = load.i64 %ptr_x
    %val_y = load.i64 %ptr_y
    %val_z = load.i64 %ptr_z

    # Copy values to avoid direct assignment
    %result_x = add.i64 %val_x, 0
    %result_y = add.i64 %val_y, 0
    %result_z = add.i64 %val_z, 0

    # Result: x + y*100 + z*10000
    %y_scaled = mul.i64 %result_y, 100
    %z_scaled = mul.i64 %result_z, 10000

    %sum1 = add.i64 %result_x, %y_scaled
    %result = add.i64 %sum1, %z_scaled

    ret.i64 %result
}

fn @main() -> i64 {
  entry:
    %mixed_result = call @test_mixed_field_sizes()
    %dummy = call @print_number(%mixed_result)
    %newline = writebyte 10
    ret.i64 0
}

# Helper function to print multi-digit numbers
fn @print_number(i64 %num) -> i64 {
  entry:
    # Handle zero case
    %is_zero = eq.i64 %num, 0
    br %is_zero, print_zero, check_negative

  check_negative:
    %is_negative = lt.i64 %num, 0
    br %is_negative, handle_negative, print_digits

  print_zero:
    %zero = writebyte 48  # '0'
    ret.i64 0

  handle_negative:
    %minus = writebyte 45  # '-'
    %abs_num = sub.i64 0, %num
    %dummy = call @print_digits(%abs_num)
    ret.i64 0

  print_digits:
    %dummy = call @print_digits(%num)
    ret.i64 0
}

# Helper function to print digits recursively
fn @print_digits(i64 %num) -> i64 {
  entry:
    %is_zero = eq.i64 %num, 0
    br %is_zero, done, continue_print

  continue_print:
    %divisor = add.i64 0, 10
    %quotient = div.i64 %num, %divisor
    %temp = mul.i64 %quotient, %divisor
    %remainder = sub.i64 %num, %temp

    # Print higher digits first
    %dummy = call @print_digits(%quotient)

    # Print current digit
    %digit = add.i64 %remainder, 48  # ASCII '0'
    %dummy2 = writebyte %digit
    ret.i64 0

  done:
    ret.i64 0
}
