# Comprehensive test for tuple operations with mixed types

# ===== TUPLE OPERATIONS =====

# Test basic tuple operations
fn @test_basic_tuple_operations() -> i64 {
  entry:
    # Create tuple with mixed types
    %tuple = tuple 42, 3.14, 1, 65  # i64, f64, bool, char

    # Extract elements
    %num = extract.tuple %tuple, 0     # i64
    %pi = extract.tuple %tuple, 1      # f64
    %flag = extract.tuple %tuple, 2    # bool
    %letter = extract.tuple %tuple, 3  # char

    # Perform operations on extracted values
    %doubled = mul.i64 %num, 2         # 84
    %flag_i64 = zext.bool.i64 %flag    # 1
    %letter_i64 = zext.char.i64 %letter # 65

    # Sum compatible values
    %sum1 = add.i64 %doubled, %flag_i64
    %result = add.i64 %sum1, %letter_i64

    ret.i64 %result
}

# Test tuple with all primitive types
fn @test_all_types_tuple() -> i64 {
  entry:
    # Create tuple with all primitive types
    %big_tuple = tuple 10, 20, 30, 40, 50, 60, 70, 80, 3.5, 2.5, 1, 66
    # Indices:        0:i8, 1:u8, 2:i16, 3:u16, 4:i32, 5:u32, 6:i64, 7:u64, 8:f32, 9:f64, 10:bool, 11:char

    # Extract and convert to i64 for summation
    %i8_val = extract.tuple %big_tuple, 0
    %u8_val = extract.tuple %big_tuple, 1
    %i16_val = extract.tuple %big_tuple, 2
    %u16_val = extract.tuple %big_tuple, 3
    %i32_val = extract.tuple %big_tuple, 4
    %u32_val = extract.tuple %big_tuple, 5
    %i64_val = extract.tuple %big_tuple, 6
    %bool_val = extract.tuple %big_tuple, 10
    %char_val = extract.tuple %big_tuple, 11

    # Convert to i64
    %i8_i64 = zext.i8.i64 %i8_val
    %u8_i64 = zext.u8.i64 %u8_val
    %i16_i64 = zext.i16.i64 %i16_val
    %u16_i64 = zext.u16.i64 %u16_val
    %i32_i64 = zext.i32.i64 %i32_val
    %u32_i64 = zext.u32.i64 %u32_val
    %bool_i64 = zext.bool.i64 %bool_val
    %char_i64 = zext.char.i64 %char_val

    # Sum all values (excluding u64 and i64 for simplicity)
    %sum1 = add.i64 %i8_i64, %u8_i64
    %sum2 = add.i64 %sum1, %i16_i64
    %sum3 = add.i64 %sum2, %u16_i64
    %sum4 = add.i64 %sum3, %i32_i64
    %sum5 = add.i64 %sum4, %u32_i64
    %sum6 = add.i64 %sum5, %bool_i64
    %result = add.i64 %sum6, %char_i64

    ret.i64 %result
}

# Test tuple nesting and complex operations
fn @test_nested_tuple_operations() -> i64 {
  entry:
    # Create nested tuples (tuples containing other tuples)
    %inner1 = tuple 10, 20
    %inner2 = tuple 30, 40
    %outer = tuple %inner1, %inner2, 50

    # Extract inner tuples
    %tuple1 = extract.tuple %outer, 0
    %tuple2 = extract.tuple %outer, 1
    %extra = extract.tuple %outer, 2

    # Extract values from inner tuples
    %val1 = extract.tuple %tuple1, 0
    %val2 = extract.tuple %tuple1, 1
    %val3 = extract.tuple %tuple2, 0
    %val4 = extract.tuple %tuple2, 1

    # Sum all values
    %sum1 = add.i64 %val1, %val2
    %sum2 = add.i64 %sum1, %val3
    %sum3 = add.i64 %sum2, %val4
    %result = add.i64 %sum3, %extra

    ret.i64 %result
}

# Test tuple with array elements
fn @test_tuple_with_arrays() -> i64 {
  entry:
    # Create arrays
    %arr1 = alloc.stack [3 x i32]
    %arr2 = alloc.stack [2 x i64]

    # Initialize arrays
    %ptr10 = getelementptr %arr1, 0
    %ptr11 = getelementptr %arr1, 1
    %ptr12 = getelementptr %arr1, 2
    store.i32 %ptr10, 1
    store.i32 %ptr11, 2
    store.i32 %ptr12, 3

    %ptr20 = getelementptr %arr2, 0
    %ptr21 = getelementptr %arr2, 1
    store.i64 %ptr20, 10
    store.i64 %ptr21, 20

    # Create tuple containing arrays and scalar
    %tuple = tuple %arr1, %arr2, 100

    # Extract arrays from tuple
    %extracted_arr1 = extract.tuple %tuple, 0
    %extracted_arr2 = extract.tuple %tuple, 1
    %scalar = extract.tuple %tuple, 2

    # Access array elements through extracted pointers
    %elem10 = getelementptr %extracted_arr1, 0
    %elem11 = getelementptr %extracted_arr1, 1
    %elem20 = getelementptr %extracted_arr2, 0

    # Load values
    %val10 = load.i32 %elem10
    %val11 = load.i32 %elem11
    %val20 = load.i64 %elem20

    # Calculate result
    %sum_arrays = add.i32 %val10, %val11
    %sum_arrays_i64 = zext.i32.i64 %sum_arrays
    %total = add.i64 %sum_arrays_i64, %val20
    %final = add.i64 %total, %scalar

    ret.i64 %final
}

# Test tuple with struct elements
fn @test_tuple_with_structs() -> i64 {
  entry:
    # Define a simple struct
    type @SimplePoint = struct { x: i32, y: i32 }

    # Create structs
    %point1 = alloc.stack struct { x: i32, y: i32 }
    %point2 = alloc.stack struct { x: i32, y: i32 }

    # Initialize structs
    %p1_x_ptr = getfieldptr %point1, 0
    %p1_y_ptr = getfieldptr %point1, 1
    store.i32 %p1_x_ptr, 5
    store.i32 %p1_y_ptr, 10

    %p2_x_ptr = getfieldptr %point2, 0
    %p2_y_ptr = getfieldptr %point2, 1
    store.i32 %p2_x_ptr, 15
    store.i32 %p2_y_ptr, 25

    # Create tuple containing structs
    %tuple = tuple %point1, %point2, 42

    # Extract structs from tuple
    %extracted_p1 = extract.tuple %tuple, 0
    %extracted_p2 = extract.tuple %tuple, 1
    %number = extract.tuple %tuple, 2

    # Access struct fields through extracted pointers
    %ep1_x_ptr = getfieldptr %extracted_p1, 0
    %ep1_y_ptr = getfieldptr %extracted_p1, 1
    %ep2_x_ptr = getfieldptr %extracted_p2, 0
    %ep2_y_ptr = getfieldptr %extracted_p2, 1

    # Load values
    %p1x = load.i32 %ep1_x_ptr
    %p1y = load.i32 %ep1_y_ptr
    %p2x = load.i32 %ep2_x_ptr
    %p2y = load.i32 %ep2_y_ptr

    # Calculate sum of all coordinates
    %sum_x = add.i32 %p1x, %p2x
    %sum_y = add.i32 %p1y, %p2y
    %total_coords = add.i32 %sum_x, %sum_y
    %total_coords_i64 = zext.i32.i64 %total_coords
    %result = add.i64 %total_coords_i64, %number

    ret.i64 %result
}

# Test tuple manipulation and reconstruction
fn @test_tuple_manipulation() -> i64 {
  entry:
    # Create initial tuple
    %original = tuple 1, 2, 3, 4

    # Extract all elements
    %elem0 = extract.tuple %original, 0
    %elem1 = extract.tuple %original, 1
    %elem2 = extract.tuple %original, 2
    %elem3 = extract.tuple %original, 3

    # Modify elements
    %new_elem0 = add.i64 %elem0, 10  # 11
    %new_elem1 = mul.i64 %elem1, 2   # 4
    %new_elem2 = sub.i64 %elem2, 1   # 2
    %new_elem3 = div.i64 %elem3, 2   # 2

    # Create new tuple with modified values
    %modified = tuple %new_elem0, %new_elem1, %new_elem2, %new_elem3

    # Extract from modified tuple and sum
    %m0 = extract.tuple %modified, 0
    %m1 = extract.tuple %modified, 1
    %m2 = extract.tuple %modified, 2
    %m3 = extract.tuple %modified, 3

    %sum1 = add.i64 %m0, %m1
    %sum2 = add.i64 %sum1, %m2
    %result = add.i64 %sum2, %m3

    ret.i64 %result
}

# Test empty tuple (unit type)
fn @test_empty_tuple() -> i64 {
  entry:
    # Create empty tuple
    %empty = tuple

    # Empty tuples don't have elements to extract
    # Just return a constant to show it works
    %result = add.i64 0, 42
    ret.i64 %result
}

# Test tuple with function results
fn @test_tuple_with_function_results() -> i64 {
  entry:
    # Define helper functions
    type @HelperResult = tuple i64, bool

    # Call functions that return tuples
    %result1 = call @create_tuple_result_1()
    %result2 = call @create_tuple_result_2()

    # Extract values from results
    %val1 = extract.tuple %result1, 0
    %flag1 = extract.tuple %result1, 1
    %val2 = extract.tuple %result2, 0
    %flag2 = extract.tuple %result2, 1

    # Combine results
    %sum_vals = add.i64 %val1, %val2
    %flag1_i64 = zext.bool.i64 %flag1
    %flag2_i64 = zext.bool.i64 %flag2
    %sum_flags = add.i64 %flag1_i64, %flag2_i64
    %result = add.i64 %sum_vals, %sum_flags

    ret.i64 %result
}

# Helper function for tuple testing
fn @create_tuple_result_1() -> tuple i64, bool {
  entry:
    %result = tuple 100, 1
    ret.tuple %result
}

# Helper function for tuple testing
fn @create_tuple_result_2() -> tuple i64, bool {
  entry:
    %result = tuple 200, 0
    ret.tuple %result
}

# ===== MAIN FUNCTION =====

fn @main() -> i64 {
  entry:
    # Test all tuple operations
    %basic_result = call @test_basic_tuple_operations()
    %all_types_result = call @test_all_types_tuple()
    %nested_result = call @test_nested_tuple_operations()
    %array_result = call @test_tuple_with_arrays()
    %struct_result = call @test_tuple_with_structs()
    %manipulate_result = call @test_tuple_manipulation()
    %empty_result = call @test_empty_tuple()
    %function_result = call @test_tuple_with_function_results()

    # Print results
    print %basic_result
    print %all_types_result
    print %nested_result
    print %array_result
    print %struct_result
    print %manipulate_result
    print %empty_result
    print %function_result

    ret.i64 0
}
