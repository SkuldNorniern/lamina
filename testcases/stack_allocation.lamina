# Test stack memory allocation (automatic lifetime management)
fn @test_stack_allocation() -> i64 {
  entry:
    # Allocate memory on stack (automatically freed when function returns)
    %stack_ptr = alloc.stack i64
    %value = add.i64 25, 0

    # Store and load from stack memory
    store.i64 %stack_ptr, %value
    %loaded = load.i64 %stack_ptr

    # Use the value
    %result = mul.i64 %loaded, 2

    ret.i64 %result  # stack_ptr automatically freed here
}

fn @test_nested_stack_operations() -> i64 {
  entry:
    # Multiple stack allocations
    %ptr1 = alloc.stack i64
    %ptr2 = alloc.stack i64

    # Store values
    store.i64 %ptr1, 10
    store.i64 %ptr2, 20

    # Load and compute
    %val1 = load.i64 %ptr1
    %val2 = load.i64 %ptr2
    %sum = add.i64 %val1, %val2

    # More operations
    %ptr3 = alloc.stack i64
    store.i64 %ptr3, %sum
    %final = load.i64 %ptr3
    %result = mul.i64 %final, 3

    ret.i64 %result  # All stack allocations automatically freed
}

fn @test_stack_vs_heap_comparison() -> i64 {
  entry:
    # Test store and load operations
    %stack_var = alloc.stack i64
    store.i64 %stack_var, 100
    %stack_val = load.i64 %stack_var
    ret.i64 %stack_val
}

fn @main() -> i64 {
  entry:
    %result1 = call @test_stack_allocation()      # Should return 50 (25 * 2)
    %result2 = call @test_nested_stack_operations() # Should return 90 ((10 + 20) * 3)
    %result3 = call @test_stack_vs_heap_comparison() # Should return 100

    print %result1
    print %result2
    print %result3

    ret.i64 0
}
