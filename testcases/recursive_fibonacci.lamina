# Test recursive fibonacci with different inputs
fn @fibonacci(i64 %n) -> i64 {
  entry:
    %is_zero = eq.i64 %n, 0
    br %is_zero, return_zero, check_one

  return_zero:
    ret.i64 0

  check_one:
    %is_one = eq.i64 %n, 1
    br %is_one, return_one, recursive_case

  return_one:
    ret.i64 1

  recursive_case:
    %n_minus_1 = sub.i64 %n, 1
    %n_minus_2 = sub.i64 %n, 2
    %fib_n_minus_1 = call @fibonacci(%n_minus_1)
    %fib_n_minus_2 = call @fibonacci(%n_minus_2)
    %result = add.i64 %fib_n_minus_1, %fib_n_minus_2
    ret.i64 %result
}

fn @main() -> i64 {
  entry:
    %result1 = call @fibonacci(0)  # Should be 0
    %result2 = call @fibonacci(1)  # Should be 1
    %result3 = call @fibonacci(2)  # Should be 1
    %result4 = call @fibonacci(3)  # Should be 2
    %result5 = call @fibonacci(4)  # Should be 3
    %result6 = call @fibonacci(5)  # Should be 5
    
    print %result1
    print %result2
    print %result3
    print %result4
    print %result5
    print %result6
    ret.i64 0
}

