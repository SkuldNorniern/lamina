# Test case to expose register size mismatch bugs
# Different data types need different register sizes, but code might use wrong registers

fn @test_i8_register_operations() -> i64 {
  entry:
    # Test i8 operations that might use wrong registers
    %a = add.i8 100, 50
    %b = sub.i8 120, 30
    %c = mul.i8 %a, 2

    # Convert to i64
    %a64 = zext.i8.i64 %a
    %b64 = zext.i8.i64 %b
    %c64 = zext.i8.i64 %c

    # Result: a + b*256 + c*65536
    %b_scaled = mul.i64 %b64, 256
    %c_scaled = mul.i64 %c64, 65536

    %s1 = add.i64 %a64, %b_scaled
    %result = add.i64 %s1, %c_scaled

    ret.i64 %result
}

fn @test_i16_register_operations() -> i64 {
  entry:
    # Test i16 operations
    %a = add.i16 1000, 500
    %b = sub.i16 1500, 300
    %c = mul.i16 %a, 3

    # Convert to i64
    %a64 = zext.i16.i64 %a
    %b64 = zext.i16.i64 %b
    %c64 = zext.i16.i64 %c

    # Result: a + b*1000000 + c*1000000000000
    %b_scaled = mul.i64 %b64, 1000000
    %c_scaled = mul.i64 %c64, 1000000000000

    %s1 = add.i64 %a64, %b_scaled
    %result = add.i64 %s1, %c_scaled

    ret.i64 %result
}

fn @test_mixed_size_operations() -> i64 {
  entry:
    # Mix different sizes in operations
    %i8_val = add.i8 42, 8
    %i16_val = add.i16 1000, 200
    %i32_val = add.i32 100000, 50000

    # Convert all to i64
    %i8_64 = zext.i8.i64 %i8_val
    %i16_64 = zext.i16.i64 %i16_val
    %i32_64 = zext.i32.i64 %i32_val

    # Result: i8 + i16*1000 + i32*1000000
    %i16_scaled = mul.i64 %i16_64, 1000
    %i32_scaled = mul.i64 %i32_64, 1000000

    %s1 = add.i64 %i8_64, %i16_scaled
    %result = add.i64 %s1, %i32_scaled

    ret.i64 %result
}

fn @test_division_small_types() -> i64 {
  entry:
    # Test division operations for small types (known to have issues)
    %i8_div = div.i8 100, 5
    %i16_div = div.i16 2000, 4
    %u8_div = div.u8 150, 3
    %u16_div = div.u16 3000, 6

    # Convert to i64
    %i8_64 = zext.i8.i64 %i8_div
    %i16_64 = zext.i16.i64 %i16_div
    %u8_64 = zext.u8.i64 %u8_div
    %u16_64 = zext.u16.i64 %u16_div

    # Result: i8 + i16*256 + u8*65536 + u16*16777216
    %i16_scaled = mul.i64 %i16_64, 256
    %u8_scaled = mul.i64 %u8_64, 65536
    %u16_scaled = mul.i64 %u16_64, 16777216

    %s1 = add.i64 %i8_64, %i16_scaled
    %s2 = add.i64 %s1, %u8_scaled
    %result = add.i64 %s2, %u16_scaled

    ret.i64 %result
}

fn @main() -> i64 {
  entry:
    %i8_result = call @test_i8_register_operations()
    %i16_result = call @test_i16_register_operations()
    %mixed_result = call @test_mixed_size_operations()
    %div_result = call @test_division_small_types()

    # Combine all results with different scaling
    %i16_scaled = mul.i64 %i16_result, 1000000000000
    %mixed_scaled = mul.i64 %mixed_result, 1000000000000000000
    %div_scaled = mul.i64 %div_result, 1000000000000000000000

    %s1 = add.i64 %i8_result, %i16_scaled
    %s2 = add.i64 %s1, %mixed_scaled
    %final = add.i64 %s2, %div_scaled

    %dummy = call @print_number(%final)
    %newline = writebyte 10
    ret.i64 0
}

# Helper function to print multi-digit numbers
fn @print_number(i64 %num) -> i64 {
  entry:
    # Handle zero case
    %is_zero = eq.i64 %num, 0
    br %is_zero, print_zero, check_negative

  check_negative:
    %is_negative = lt.i64 %num, 0
    br %is_negative, handle_negative, print_digits

  print_zero:
    %zero = writebyte 48  # '0'
    ret.i64 0

  handle_negative:
    %minus = writebyte 45  # '-'
    %abs_num = sub.i64 0, %num
    %dummy = call @print_digits(%abs_num)
    ret.i64 0

  print_digits:
    %dummy = call @print_digits(%num)
    ret.i64 0
}

# Helper function to print digits recursively
fn @print_digits(i64 %num) -> i64 {
  entry:
    %is_zero = eq.i64 %num, 0
    br %is_zero, done, continue_print

  continue_print:
    %divisor = add.i64 0, 10
    %quotient = div.i64 %num, %divisor
    %temp = mul.i64 %quotient, %divisor
    %remainder = sub.i64 %num, %temp

    # Print higher digits first
    %dummy = call @print_digits(%quotient)

    # Print current digit
    %digit = add.i64 %remainder, 48  # ASCII '0'
    %dummy2 = writebyte %digit
    ret.i64 0

  done:
    ret.i64 0
}
