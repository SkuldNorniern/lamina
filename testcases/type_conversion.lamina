# Test type conversion operations (zero extension)

# Test basic zero extension from smaller to larger types
fn @test_basic_zext() -> i64 {
  entry:
    # Start with i8 value
    %small_val = add.i8 100, 0  # 100 as i8

    # Extend to i32
    %i32_val = zext.i8.i32 %small_val

    # Extend to i64
    %i64_val = zext.i32.i64 %i32_val

    # Verify the value is preserved
    %expected = add.i64 100, 0
    %is_equal = eq.i64 %i64_val, %expected

    # Return the extended value
    ret.i64 %i64_val
}

# Test zero extension in arithmetic operations
fn @test_zext_arithmetic() -> i64 {
  entry:
    # Small values
    %a_i8 = add.i8 10, 0
    %b_i8 = add.i8 20, 0

    # Extend to i32 for arithmetic
    %a_i32 = zext.i8.i32 %a_i8
    %b_i32 = zext.i8.i32 %b_i8

    # Perform arithmetic
    %sum_i32 = add.i32 %a_i32, %b_i32  # 30 as i32

    # Extend to i64
    %sum_i64 = zext.i32.i64 %sum_i32

    # More operations at i64 level
    %result = mul.i64 %sum_i64, 2  # 60 as i64

    ret.i64 %result
}

# Test zero extension with boolean values
fn @test_boolean_zext() -> i64 {
  entry:
    # Boolean values
    %true_val = add.bool 1, 0   # true
    %false_val = add.bool 0, 0  # false

    # Extend to i32
    %true_i32 = zext.bool.i32 %true_val   # Should be 1
    %false_i32 = zext.bool.i32 %false_val # Should be 0

    # Extend to i64
    %true_i64 = zext.i32.i64 %true_i32   # Should be 1
    %false_i64 = zext.i32.i64 %false_i32 # Should be 0

    # Calculate: true_i64 + false_i64
    %result = add.i64 %true_i64, %false_i64

    ret.i64 %result
}

# Test zero extension in conditional logic
fn @test_zext_conditionals() -> i64 {
  entry:
    %x_i8 = add.i8 50, 0
    %y_i8 = add.i8 30, 0

    # Extend for comparison
    %x_i32 = zext.i8.i32 %x_i8
    %y_i32 = zext.i8.i32 %y_i8

    %is_greater = gt.i32 %x_i32, %y_i32  # true (50 > 30)

    # Extend boolean result to i64
    %result_i64 = zext.bool.i64 %is_greater  # Should be 1

    ret.i64 %result_i64
}

# Test chained zero extensions
fn @test_chained_zext() -> i64 {
  entry:
    # Start with i8
    %val_i8 = add.i8 7, 0

    # Chain extensions: i8 -> i32 -> i64 (skip i16 for now)
    %val_i32 = zext.i8.i32 %val_i8
    %val_i64 = zext.i32.i64 %val_i32

    # Verify value preservation
    %expected = add.i64 7, 0
    %is_correct = eq.i64 %val_i64, %expected

    # Return 1 if correct, 0 if not
    %result = zext.bool.i64 %is_correct

    ret.i64 %result
}

# Test zero extension with overflow consideration
fn @test_zext_overflow() -> i64 {
  entry:
    # i8 maximum value (127)
    %max_i8 = add.i8 127, 0

    # Extend to i32 - should preserve value
    %max_i32 = zext.i8.i32 %max_i8

    # Extend to i64
    %max_i64 = zext.i32.i64 %max_i32

    # Verify it's still 127
    %expected = add.i64 127, 0
    %is_correct = eq.i64 %max_i64, %expected

    %result = zext.bool.i64 %is_correct
    ret.i64 %result
}

# Test zero extension in function calls
fn @double_value(i32 %input) -> i64 {
  entry:
    %doubled_i32 = mul.i32 %input, 2
    %result_i64 = zext.i32.i64 %doubled_i32
    ret.i64 %result_i64
}

fn @test_zext_functions() -> i64 {
  entry:
    # Small i8 value
    %small_i8 = add.i8 25, 0

    # Extend to i32 for function call
    %i32_val = zext.i8.i32 %small_i8

    # Call function
    %result = call @double_value(%i32_val)  # Should double 25 to 50

    ret.i64 %result
}

fn @main() -> i64 {
  entry:
    %basic_result = call @test_basic_zext()        # Should return 100
    %arith_result = call @test_zext_arithmetic()   # Should return 60
    %bool_result = call @test_boolean_zext()       # Should return 1
    %cond_result = call @test_zext_conditionals()  # Should return 1
    %chain_result = call @test_chained_zext()      # Should return 1
    %overflow_result = call @test_zext_overflow()  # Should return 1
    %func_result = call @test_zext_functions()     # Should return 50

    print %basic_result
    print %arith_result
    print %bool_result
    print %cond_result
    print %chain_result
    print %overflow_result
    print %func_result

    ret.i64 0
}
