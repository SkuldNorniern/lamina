# Comprehensive test for struct operations with mixed field types

# Struct types are defined inline with alloc.stack

# ===== STRUCT OPERATIONS =====

# Test basic Point2D operations
fn @test_point2d_operations() -> i64 {
  entry:
    # Allocate Point2D struct
    %point = alloc.stack struct { x: i32, y: i32 }

    # Get field pointers
    %x_ptr = getfieldptr %point, 0
    %y_ptr = getfieldptr %point, 1

    # Store values
    store.i32 %x_ptr, 10
    store.i32 %y_ptr, 20

    # Load values
    %x = load.i32 %x_ptr
    %y = load.i32 %y_ptr

    # Calculate distance squared: x² + y²
    %x_sq = mul.i32 %x, %x
    %y_sq = mul.i32 %y, %y
    %dist_sq = add.i32 %x_sq, %y_sq

    # Convert result to i64
    %result = zext.i32.i64 %dist_sq
    ret.i64 %result
}

# Test Point3D operations
fn @test_point3d_operations() -> i64 {
  entry:
    # Allocate Point3D struct
    %point = alloc.stack struct { x: i64, y: i64, z: i64 }

    # Get field pointers
    %x_ptr = getfieldptr %point, 0
    %y_ptr = getfieldptr %point, 1
    %z_ptr = getfieldptr %point, 2

    # Store values
    store.i64 %x_ptr, 3
    store.i64 %y_ptr, 4
    store.i64 %z_ptr, 5

    # Load values
    %x = load.i64 %x_ptr
    %y = load.i64 %y_ptr
    %z = load.i64 %z_ptr

    # Calculate magnitude squared: x² + y² + z²
    %x_sq = mul.i64 %x, %x
    %y_sq = mul.i64 %y, %y
    %z_sq = mul.i64 %z, %z
    %xy_sum = add.i64 %x_sq, %y_sq
    %magnitude_sq = add.i64 %xy_sum, %z_sq

    ret.i64 %magnitude_sq
}

# Test Person struct (mixed types)
fn @test_person_operations() -> i64 {
  entry:
    # Allocate Person struct
    %person = alloc.stack struct { name: [10 x char], age: u8, height: f32 }

    # Get field pointers
    %name_ptr = getfieldptr %person, 0
    %age_ptr = getfieldptr %person, 1
    %height_ptr = getfieldptr %person, 2

    # Store name (first 3 characters)
    %name0 = getelementptr %name_ptr, 0
    %name1 = getelementptr %name_ptr, 1
    %name2 = getelementptr %name_ptr, 2
    store.char %name0, 74  # 'J'
    store.char %name1, 79  # 'O'
    store.char %name2, 72  # 'H'

    # Store age and height
    store.u8 %age_ptr, 25
    store.f32 %height_ptr, 175.5

    # Load values
    %age = load.u8 %age_ptr
    %first_char = load.char %name0

    # Combine results
    %age_i64 = zext.u8.i64 %age
    %char_i64 = zext.char.i64 %first_char
    %combined = add.i64 %age_i64, %char_i64

    ret.i64 %combined
}

# Test ComplexData struct
fn @test_complex_data_operations() -> i64 {
  entry:
    # Allocate ComplexData struct
    %data = alloc.stack struct { id: u32, value: f64, active: bool }

    # Get field pointers
    %id_ptr = getfieldptr %data, 0
    %value_ptr = getfieldptr %data, 1
    %active_ptr = getfieldptr %data, 2

    # Store values
    store.u32 %id_ptr, 12345
    store.f64 %value_ptr, 99.99
    store.bool %active_ptr, 1

    # Load and check values
    %id = load.u32 %id_ptr
    %active = load.bool %active_ptr

    # Use active flag to conditionally return id
    %id_i64 = zext.u32.i64 %id
    %active_i64 = zext.bool.i64 %active
    %result = mul.i64 %id_i64, %active_i64

    ret.i64 %result
}

# Test MixedTypes struct (all primitive types)
fn @test_mixed_types_operations() -> i64 {
  entry:
    # Allocate MixedTypes struct
    %mixed = alloc.stack struct { a: i8, b: u16, c: i32, d: u64, e: f32, f: bool, g: char }

    # Get all field pointers
    %a_ptr = getfieldptr %mixed, 0  # i8
    %b_ptr = getfieldptr %mixed, 1  # u16
    %c_ptr = getfieldptr %mixed, 2  # i32
    %d_ptr = getfieldptr %mixed, 3  # u64
    %e_ptr = getfieldptr %mixed, 4  # f32
    %f_ptr = getfieldptr %mixed, 5  # bool
    %g_ptr = getfieldptr %mixed, 6  # char

    # Store test values
    store.i8 %a_ptr, 10
    store.u16 %b_ptr, 1000
    store.i32 %c_ptr, 100000
    store.u64 %d_ptr, 1000000
    store.f32 %e_ptr, 3.14
    store.bool %f_ptr, 1
    store.char %g_ptr, 65  # 'A'

    # Load and sum compatible values
    %a_val = load.i8 %a_ptr
    %b_val = load.u16 %b_ptr
    %c_val = load.i32 %c_ptr
    %f_val = load.bool %f_ptr
    %g_val = load.char %g_ptr

    # Convert to common type (i64) for summation
    %a_i64 = zext.i8.i64 %a_val
    %b_i64 = zext.u16.i64 %b_val
    %c_i64 = zext.i32.i64 %c_val
    %f_i64 = zext.bool.i64 %f_val
    %g_i64 = zext.char.i64 %g_val

    # Calculate sum
    %sum1 = add.i64 %a_i64, %b_i64
    %sum2 = add.i64 %sum1, %c_i64
    %sum3 = add.i64 %sum2, %f_i64
    %total = add.i64 %sum3, %g_i64

    ret.i64 %total
}

# Test struct copying and comparison
fn @test_struct_copy_operations() -> i64 {
  entry:
    # Allocate two Point2D structs
    %point1 = alloc.stack struct { x: i32, y: i32 }
    %point2 = alloc.stack struct { x: i32, y: i32 }

    # Initialize point1
    %p1_x_ptr = getfieldptr %point1, 0
    %p1_y_ptr = getfieldptr %point1, 1
    store.i32 %p1_x_ptr, 5
    store.i32 %p1_y_ptr, 10

    # Copy values to point2
    %p2_x_ptr = getfieldptr %point2, 0
    %p2_y_ptr = getfieldptr %point2, 1

    %x_val = load.i32 %p1_x_ptr
    %y_val = load.i32 %p1_y_ptr

    store.i32 %p2_x_ptr, %x_val
    store.i32 %p2_y_ptr, %y_val

    # Verify copy worked
    %p2_x_val = load.i32 %p2_x_ptr
    %p2_y_val = load.i32 %p2_y_ptr

    %x_equal = eq.i32 %x_val, %p2_x_val
    %y_equal = eq.i32 %y_val, %p2_y_val

    # Both should be true (1), sum should be 2
    %x_i64 = zext.bool.i64 %x_equal
    %y_i64 = zext.bool.i64 %y_equal
    %result = add.i64 %x_i64, %y_i64

    ret.i64 %result
}

# Test nested struct operations
fn @test_nested_struct_operations() -> i64 {
  entry:
    # Define nested struct type inline

    # Allocate Line struct
    %line = alloc.stack struct { start: struct { x: i32, y: i32 }, end: struct { x: i32, y: i32 } }

    # Get pointers to nested structs
    %start_ptr = getfieldptr %line, 0
    %end_ptr = getfieldptr %line, 1

    # Set start point (1, 2)
    %start_x_ptr = getfieldptr %start_ptr, 0
    %start_y_ptr = getfieldptr %start_ptr, 1
    store.i32 %start_x_ptr, 1
    store.i32 %start_y_ptr, 2

    # Set end point (4, 6)
    %end_x_ptr = getfieldptr %end_ptr, 0
    %end_y_ptr = getfieldptr %end_ptr, 1
    store.i32 %end_x_ptr, 4
    store.i32 %end_y_ptr, 6

    # Calculate length (simplified Manhattan distance)
    %start_x = load.i32 %start_x_ptr
    %start_y = load.i32 %start_y_ptr
    %end_x = load.i32 %end_x_ptr
    %end_y = load.i32 %end_y_ptr

    %dx = sub.i32 %end_x, %start_x
    %dy = sub.i32 %end_y, %start_y

    # Use simple addition for testing (simplified)
    %length = add.i32 %dx, %dy

    # Convert result to i64
    %result = zext.i32.i64 %length
    ret.i64 %result
}

# Test array of structs
fn @test_struct_array_operations() -> i64 {
  entry:
    # Allocate array of Point2D structs
    %points = alloc.stack [3 x struct { x: i32, y: i32 }]

    # Initialize each point
    %point0 = getelementptr %points, 0
    %point1 = getelementptr %points, 1
    %point2 = getelementptr %points, 2

    # Set point 0: (1, 1)
    %p0_x_ptr = getfieldptr %point0, 0
    %p0_y_ptr = getfieldptr %point0, 1
    store.i32 %p0_x_ptr, 1
    store.i32 %p0_y_ptr, 1

    # Set point 1: (2, 3)
    %p1_x_ptr = getfieldptr %point1, 0
    %p1_y_ptr = getfieldptr %point1, 1
    store.i32 %p1_x_ptr, 2
    store.i32 %p1_y_ptr, 3

    # Set point 2: (4, 7)
    %p2_x_ptr = getfieldptr %point2, 0
    %p2_y_ptr = getfieldptr %point2, 1
    store.i32 %p2_x_ptr, 4
    store.i32 %p2_y_ptr, 7

    # Calculate sum of all x coordinates
    %x0 = load.i32 %p0_x_ptr
    %x1 = load.i32 %p1_x_ptr
    %x2 = load.i32 %p2_x_ptr

    %x01 = add.i32 %x0, %x1
    %x_total = add.i32 %x01, %x2

    # Calculate sum of all y coordinates
    %y0 = load.i32 %p0_y_ptr
    %y1 = load.i32 %p1_y_ptr
    %y2 = load.i32 %p2_y_ptr

    %y01 = add.i32 %y0, %y1
    %y_total = add.i32 %y01, %y2

    # Total sum
    %grand_total = add.i32 %x_total, %y_total

    # Convert result to i64
    %result = zext.i32.i64 %grand_total
    ret.i64 %result
}

# ===== MAIN FUNCTION =====

fn @main() -> i64 {
  entry:
    # Test all struct operations
    %point2d_result = call @test_point2d_operations()
    %point3d_result = call @test_point3d_operations()
    %person_result = call @test_person_operations()
    %complex_result = call @test_complex_data_operations()
    %mixed_result = call @test_mixed_types_operations()
    %copy_result = call @test_struct_copy_operations()
    %nested_result = call @test_nested_struct_operations()
    %array_result = call @test_struct_array_operations()

    # Print results
    print %point2d_result
    print %point3d_result
    print %person_result
    print %complex_result
    print %mixed_result
    print %copy_result
    print %nested_result
    print %array_result

    ret.i64 0
}
