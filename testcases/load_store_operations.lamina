# Test load and store memory operations

# Test basic load/store operations
fn @test_basic_load_store() -> i64 {
  entry:
    # Allocate memory
    %ptr = alloc.stack i64

    # Store a value
    %value = add.i64 42, 0
    store i64 %ptr, %value

    # Load the value back
    %loaded = load i64 %ptr

    # Verify they're equal
    %is_equal = eq.i64 %value, %loaded
    %result = zext i1 i64 %is_equal

    ret.i64 %result
}

# Test multiple load/store operations
fn @test_multiple_operations() -> i64 {
  entry:
    %ptr1 = alloc.stack i32
    %ptr2 = alloc.stack i32
    %ptr3 = alloc.stack i32

    # Store different values
    store i32 %ptr1, 10
    store i32 %ptr2, 20
    store i32 %ptr3, 30

    # Load and modify
    %val1 = load i32 %ptr1
    %val2 = load i32 %ptr2
    %val3 = load i32 %ptr3

    # Store modified values
    %new_val1 = add.i32 %val1, 5   # 15
    %new_val2 = mul.i32 %val2, 2   # 40
    %new_val3 = sub.i32 %val3, 10  # 20

    store i32 %ptr1, %new_val1
    store i32 %ptr2, %new_val2
    store i32 %ptr3, %new_val3

    # Load final values and sum
    %final1 = load i32 %ptr1
    %final2 = load i32 %ptr2
    %final3 = load i32 %ptr3

    # Extend to i64 for summation
    %f1_i64 = zext i32 i64 %final1
    %f2_i64 = zext i32 i64 %final2
    %f3_i64 = zext i32 i64 %final3

    %sum1 = add.i64 %f1_i64, %f2_i64
    %total = add.i64 %sum1, %f3_i64

    ret.i64 %total  # Should be 75 (15 + 40 + 20)
}

# Test load/store with different data types
fn @test_different_types() -> i64 {
  entry:
    # Different type allocations
    %i32_ptr = alloc.stack i32
    %i64_ptr = alloc.stack i64
    %bool_ptr = alloc.stack i1

    # Store values
    store i32 %i32_ptr, 100
    store i64 %i64_ptr, 200
    store i1 %bool_ptr, 1  # true

    # Load values
    %i32_val = load i32 %i32_ptr
    %i64_val = load i64 %i64_ptr
    %bool_val = load i1 %bool_ptr

    # Convert everything to i64
    %i32_extended = zext i32 i64 %i32_val
    %bool_extended = zext i1 i64 %bool_val

    # Calculate: i32_val + i64_val + bool_val
    %sum1 = add.i64 %i32_extended, %i64_val
    %total = add.i64 %sum1, %bool_extended

    ret.i64 %total  # Should be 301 (100 + 200 + 1)
}

# Test load/store with heap memory
fn @test_heap_load_store() -> i64 {
  entry:
    # Allocate on heap
    %heap_ptr = alloc.heap i64

    # Store value
    %value = add.i64 999, 0
    store i64 %heap_ptr, %value

    # Load value
    %loaded = load i64 %heap_ptr

    # Modify and store again
    %modified = add.i64 %loaded, 1
    store i64 %heap_ptr, %modified

    # Load final value
    %final = load i64 %heap_ptr

    # TODO: Clean up
    # dealloc %heap_ptr

    ret.i64 %final  # Should be 1000
}

# Test memory aliasing (same pointer used differently)
fn @test_memory_aliasing() -> i64 {
  entry:
    %ptr = alloc.stack i64

    # Store initial value
    store i64 %ptr, 50

    # Load through different "paths" (conceptually)
    %val1 = load i64 %ptr
    %val2 = load i64 %ptr  # Same memory location

    # Modify through one reference
    %new_val = add.i64 %val1, 25
    store i64 %ptr, %new_val

    # Load through other reference
    %val3 = load i64 %ptr

    # All should be the same final value
    %sum = add.i64 %val1, %val2
    %total = add.i64 %sum, %val3

    ret.i64 %total  # Should be 150 (50 + 50 + 75)
}

# Test load/store in loop-like patterns
fn @test_sequential_access() -> i64 {
  entry:
    %ptr = alloc.stack i64

    # Initialize
    store i64 %ptr, 0

    # Simulate loop: add 1 ten times
    %current = load i64 %ptr
    %step1 = add.i64 %current, 1
    store i64 %ptr, %step1

    %current = load i64 %ptr
    %step2 = add.i64 %current, 1
    store i64 %ptr, %step2

    %current = load i64 %ptr
    %step3 = add.i64 %current, 1
    store i64 %ptr, %step3

    %current = load i64 %ptr
    %step4 = add.i64 %current, 1
    store i64 %ptr, %step4

    %current = load i64 %ptr
    %step5 = add.i64 %current, 1
    store i64 %ptr, %step5

    %current = load i64 %ptr
    %step6 = add.i64 %current, 1
    store i64 %ptr, %step6

    %current = load i64 %ptr
    %step7 = add.i64 %current, 1
    store i64 %ptr, %step7

    %current = load i64 %ptr
    %step8 = add.i64 %current, 1
    store i64 %ptr, %step8

    %current = load i64 %ptr
    %step9 = add.i64 %current, 1
    store i64 %ptr, %step9

    %current = load i64 %ptr
    %step10 = add.i64 %current, 1
    store i64 %ptr, %step10

    # Load final result
    %final = load i64 %ptr

    ret.i64 %final  # Should be 10
}

fn @main() -> i64 {
  entry:
    %basic_result = call @test_basic_load_store()      # Should return 1 (true)
    %multi_result = call @test_multiple_operations()   # Should return 75
    %types_result = call @test_different_types()       # Should return 301
    %heap_result = call @test_heap_load_store()        # Should return 1000
    %alias_result = call @test_memory_aliasing()       # Should return 150
    %seq_result = call @test_sequential_access()       # Should return 10

    print %basic_result
    print %multi_result
    print %types_result
    print %heap_result
    print %alias_result
    print %seq_result

    ret.i64 0
}
