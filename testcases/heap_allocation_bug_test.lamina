# Test case to expose heap allocation and deallocation bugs
# This test uses heap allocation/deallocation to verify correct memory management
# If bugs exist, heap operations may not work correctly or may cause memory leaks

fn @test_heap_allocation() -> i64 {
  entry:
    # Allocate heap memory for i32
    %heap_ptr = alloc.heap i32

    # Store a value
    store.i32 %heap_ptr, 12345

    # Load and verify the value
    %loaded_val = load.i32 %heap_ptr

    # Convert to i64 for return
    %result = zext.i32.i64 %loaded_val
    ret.i64 %result
}

fn @test_heap_array() -> i64 {
  entry:
    # Allocate heap array
    %heap_array = alloc.heap [5 x i32]

    # Store values in array elements
    %ptr0 = getelem.ptr %heap_array, 0, i32
    %ptr1 = getelem.ptr %heap_array, 1, i32
    %ptr2 = getelem.ptr %heap_array, 2, i32

    store.i32 %ptr0, 100
    store.i32 %ptr1, 200
    store.i32 %ptr2, 300

    # Load and sum values
    %val0 = load.i32 %ptr0
    %val1 = load.i32 %ptr1
    %val2 = load.i32 %ptr2

    %sum1 = add.i32 %val0, %val1
    %total = add.i32 %sum1, %val2

    %result = zext.i32.i64 %total
    ret.i64 %result
}

fn @test_heap_struct() -> i64 {
  entry:
    # Allocate heap struct
    %heap_struct = alloc.heap struct { x: i32, y: i32 }

    # Access struct fields
    %ptr_x = getfieldptr %heap_struct, 0
    %ptr_y = getfieldptr %heap_struct, 1

    store.i32 %ptr_x, 111
    store.i32 %ptr_y, 222

    # Load and sum
    %val_x = load.i32 %ptr_x
    %val_y = load.i32 %ptr_y

    %sum = add.i32 %val_x, %val_y
    %result = zext.i32.i64 %sum
    ret.i64 %result
}

fn @test_multiple_allocations() -> i64 {
  entry:
    # Allocate multiple heap objects
    %ptr1 = alloc.heap i32
    %ptr2 = alloc.heap i64
    %ptr3 = alloc.heap [3 x i16]

    # Use them
    store.i32 %ptr1, 42
    store.i64 %ptr2, 123456789

    %arr_ptr = getelem.ptr %ptr3, 0, i16
    store.i16 %arr_ptr, 1000

    # Load and combine
    %val1 = load.i32 %ptr1
    %val2 = load.i64 %ptr2
    %val3 = load.i16 %arr_ptr

    %val1_i64 = zext.i32.i64 %val1
    %val3_i64 = zext.i16.i64 %val3

    %sum1 = add.i64 %val1_i64, %val2
    %result = add.i64 %sum1, %val3_i64

    ret.i64 %result
}

fn @main() -> i64 {
  entry:
    %heap_result = call @test_heap_allocation()
    %array_result = call @test_heap_array()
    %struct_result = call @test_heap_struct()
    %multi_result = call @test_multiple_allocations()

    %dummy1 = call @print_number(%heap_result)
    %newline1 = writebyte 10
    %dummy2 = call @print_number(%array_result)
    %newline2 = writebyte 10
    %dummy3 = call @print_number(%struct_result)
    %newline3 = writebyte 10
    %dummy4 = call @print_number(%multi_result)
    %newline4 = writebyte 10

    ret.i64 0
}

# Helper function to print multi-digit numbers
fn @print_number(i64 %num) -> i64 {
  entry:
    # Handle zero case
    %is_zero = eq.i64 %num, 0
    br %is_zero, print_zero, check_negative

  check_negative:
    %is_negative = lt.i64 %num, 0
    br %is_negative, handle_negative, print_digits

  print_zero:
    %zero = writebyte 48  # '0'
    ret.i64 0

  handle_negative:
    %minus = writebyte 45  # '-'
    %abs_num = sub.i64 0, %num
    %dummy = call @print_digits(%abs_num)
    ret.i64 0

  print_digits:
    %dummy = call @print_digits(%num)
    ret.i64 0
}

# Helper function to print digits recursively
fn @print_digits(i64 %num) -> i64 {
  entry:
    %is_zero = eq.i64 %num, 0
    br %is_zero, done, continue_print

  continue_print:
    %divisor = add.i64 0, 10
    %quotient = div.i64 %num, %divisor
    %temp = mul.i64 %quotient, %divisor
    %remainder = sub.i64 %num, %temp

    # Print higher digits first
    %dummy = call @print_digits(%quotient)

    # Print current digit
    %digit = add.i64 %remainder, 48  # ASCII '0'
    %dummy2 = writebyte %digit
    ret.i64 0

  done:
    ret.i64 0
}
