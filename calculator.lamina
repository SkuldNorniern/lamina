# Cool Calculator Program: Advanced Arithmetic Calculator
# Demonstrates Lamina's arithmetic capabilities and expression evaluation
# Shows complex mathematical operations and operator precedence
#
# Supported operations:
# - Addition, subtraction, multiplication, division
# - Complex expressions with proper order of operations
# - Multiple calculations in sequence
# - Expression evaluation with intermediate results

# Function to compute (a + b) * (a - b) = a² - b²
fn @difference_of_squares(i64 %a, i64 %b) -> i64 {
  entry:
    %sum = add.i64 %a, %b
    %diff = sub.i64 %a, %b
    %result = mul.i64 %sum, %diff
    ret.i64 %result
}

# Function to compute quadratic formula result: (-b + sqrt(b² - 4ac)) / 2a
# Simplified version without square root (just the formula structure)
fn @quadratic_formula(i64 %a, i64 %b, i64 %c) -> i64 {
  entry:
    # Compute b²
    %b_squared = mul.i64 %b, %b

    # Compute 4ac
    %four_ac = mul.i64 4, %a
    %four_ac_final = mul.i64 %four_ac, %c

    # Compute discriminant: b² - 4ac
    %discriminant = sub.i64 %b_squared, %four_ac_final

    # For demonstration, return the discriminant
    # In a real implementation, we'd compute square root
    ret.i64 %discriminant
}

# Function to compute factorial (for demonstration)
fn @factorial(i64 %n) -> i64 {
  entry:
    %is_zero = eq.i64 %n, 0
    br %is_zero, return_one, compute_fact

  return_one:
    ret.i64 1

  compute_fact:
    %n_minus_1 = sub.i64 %n, 1
    %fact_minus_1 = call @factorial(%n_minus_1)
    %result = mul.i64 %n, %fact_minus_1
    ret.i64 %result
}

# Function to compute fibonacci (for demonstration)
fn @fibonacci(i64 %n) -> i64 {
  entry:
    %is_zero = eq.i64 %n, 0
    br %is_zero, return_zero, check_one

  return_zero:
    ret.i64 0

  check_one:
    %is_one = eq.i64 %n, 1
    br %is_one, return_one, compute_fib

  return_one:
    ret.i64 1

  compute_fib:
    %n_minus_1 = sub.i64 %n, 1
    %n_minus_2 = sub.i64 %n, 2
    %fib1 = call @fibonacci(%n_minus_1)
    %fib2 = call @fibonacci(%n_minus_2)
    %result = add.i64 %fib1, %fib2
    ret.i64 %result
}

# Function to demonstrate operator precedence: a + b * c - d / e
fn @complex_expression(i64 %a, i64 %b, i64 %c, i64 %d, i64 %e) -> i64 {
  entry:
    # Compute b * c first (multiplication)
    %bc = mul.i64 %b, %c

    # Compute d / e (we'll simulate integer division)
    %de = div.i64 %d, %e

    # Compute a + (b * c)
    %first_part = add.i64 %a, %bc

    # Compute final result: (a + b*c) - (d/e)
    %result = sub.i64 %first_part, %de

    ret.i64 %result
}

# Main calculator function
fn @main() -> i64 {
  entry:
    # Header marker
    print 2001  # Calculator start

    # Test 1: Difference of squares - (5+3)×(5-3) = 8×2 = 16
    print 1001  # Test marker
    %dos_result = call @difference_of_squares(5, 3)
    print %dos_result

    # Test 2: Quadratic discriminant - for 2x² + 5x + 2 = 0
    # Discriminant = b² - 4ac = 25 - 16 = 9
    print 1002  # Test marker
    %quad_result = call @quadratic_formula(2, 5, 2)
    print %quad_result

    # Test 3: Factorial calculations
    print 1003  # Test marker
    %fact3 = call @factorial(3)
    print %fact3  # 3! = 6
    %fact4 = call @factorial(4)
    print %fact4  # 4! = 24

    # Test 4: Fibonacci numbers
    print 1004  # Test marker
    %fib5 = call @fibonacci(5)
    print %fib5  # fib(5) = 5
    %fib6 = call @fibonacci(6)
    print %fib6  # fib(6) = 8

    # Test 5: Complex expression - 10 + 3 * 4 - 8 / 2
    # Should be: 10 + 12 - 4 = 18
    print 1005  # Test marker
    %complex_result = call @complex_expression(10, 3, 4, 8, 2)
    print %complex_result

    # Test 6: Multiple operations in sequence
    print 1006  # Test marker

    # First: (7+2)×(7-2) = 9×5 = 45
    %dos1 = call @difference_of_squares(7, 2)
    print %dos1

    # Second: Add fibonacci result
    %fib_result = call @fibonacci(4)  # fib(4) = 3
    %combined = add.i64 %dos1, %fib_result
    print %combined  # 45 + 3 = 48

    # Footer
    print 2999  # Calculator end

    ret.i64 0
}









