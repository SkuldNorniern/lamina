# Cool Program: Mathematical Computation Showcase
# Demonstrates Lamina's capabilities with fibonacci sequences and recursive algorithms
# Shows off AArch64 codegen performance and functional programming features
#
# Output format:
# 1024 - Fibonacci section header
# 0,1,1,2,3,5 - Fibonacci sequence (fib(0) to fib(5))
# 2048 - Factorial section header
# 1,1,2,6,24 - Factorial sequence (0! to 4!)
# 4096 - Arithmetic section header
# 91,45 - Results of (10+3)*(10-3)=91 and (7+2)*(7-2)=45
# 8192 - Power section header
# 8,9,1 - Results of 2^3=8, 3^2=9, 5^0=1
# 16384 - End marker

# Function to compute fibonacci number recursively
fn @fibonacci(i64 %n) -> i64 {
  entry:
    %is_zero = eq.i64 %n, 0
    br %is_zero, return_zero, check_one

  return_zero:
    ret.i64 0

  check_one:
    %is_one = eq.i64 %n, 1
    br %is_one, return_one, compute_fib

  return_one:
    ret.i64 1

  compute_fib:
    %n_minus_1 = sub.i64 %n, 1
    %n_minus_2 = sub.i64 %n, 2
    %fib1 = call @fibonacci(%n_minus_1)
    %fib2 = call @fibonacci(%n_minus_2)
    %result = add.i64 %fib1, %fib2
    ret.i64 %result
}

# Function to compute factorial (demonstrates different recursive pattern)
fn @factorial(i64 %n) -> i64 {
  entry:
    %is_zero = eq.i64 %n, 0
    br %is_zero, return_one, compute_fact

  return_one:
    ret.i64 1

  compute_fact:
    %n_minus_1 = sub.i64 %n, 1
    %fact_minus_1 = call @factorial(%n_minus_1)
    %result = mul.i64 %n, %fact_minus_1
    ret.i64 %result
}

# Function to demonstrate simple arithmetic operations
fn @simple_math(i64 %x, i64 %y) -> i64 {
  entry:
    %sum = add.i64 %x, %y
    %diff = sub.i64 %x, %y
    %product = mul.i64 %sum, %diff
    ret.i64 %product
}

# Function to compute power (demonstrates accumulator pattern)
fn @power(i64 %base, i64 %exp) -> i64 {
  entry:
    %is_zero = eq.i64 %exp, 0
    br %is_zero, return_one, compute_power

  return_one:
    ret.i64 1

  compute_power:
    %exp_minus_1 = sub.i64 %exp, 1
    %power_minus_1 = call @power(%base, %exp_minus_1)
    %result = mul.i64 %base, %power_minus_1
    ret.i64 %result
}

# Main function - showcases various mathematical computations
fn @main() -> i64 {
  entry:
    # Compute and display fibonacci sequence
    print 1024  # Header marker for fibonacci section

    %fib0 = call @fibonacci(0)
    print %fib0

    %fib1 = call @fibonacci(1)
    print %fib1

    %fib2 = call @fibonacci(2)
    print %fib2

    %fib3 = call @fibonacci(3)
    print %fib3

    %fib4 = call @fibonacci(4)
    print %fib4

    %fib5 = call @fibonacci(5)
    print %fib5

    # Compute and display factorial sequence
    print 2048  # Header marker for factorial section

    %fact0 = call @factorial(0)
    print %fact0

    %fact1 = call @factorial(1)
    print %fact1

    %fact2 = call @factorial(2)
    print %fact2

    %fact3 = call @factorial(3)
    print %fact3

    %fact4 = call @factorial(4)
    print %fact4

    # Test arithmetic operations
    print 4096  # Header marker for arithmetic section

    %math1 = call @simple_math(10, 3)
    print %math1

    %math2 = call @simple_math(7, 2)
    print %math2

    # Compute power function
    print 8192  # Header marker for power section

    %power2_3 = call @power(2, 3)
    print %power2_3

    %power3_2 = call @power(3, 2)
    print %power3_2

    %power5_0 = call @power(5, 0)
    print %power5_0

    # Final marker
    print 16384

    ret.i64 0
}
